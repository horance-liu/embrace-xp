\begin{savequote}[45mm]
\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

\chapter{实现xUnit} 
\label{ch:ice-breaker}

\begin{content}

\end{content}

\section{提出问题}
	
\begin{content}

\subsection{xUnit架构}

\subsection{接口设计}

使用\ascii{C++}描述\ascii{xUnit}的样例，相对于\ascii{Google Test}，此处做了如下几个方面的革新。

\begin{enum}
  \eitem{\ascii{在同一个类域内，使得TEST与SETUP/TEARDOWN关系更加紧密；}}
  \eitem{\ascii{使用字符串描述用例；}}
  \eitem{\ascii{避免setUp, SetUp, setup大小写混用导致的错误。}}
\end{enum}


\begin{leftbar}
 \begin{c++}
#include <statck>
#include "mars/mars.h"

FIXTURE(StackSpec) {
  std::stack<int> v;   

  SETUP {
    v.push(1);
  }

  TEST("top element") {
    ASSERT_EQ(1, v.top());
  }
 
  TEARDOWN {
    v.pop();
  }
}; 
 \end{c++}
\end{leftbar}

\end{content}

\section{破冰之旅}

\begin{content}

\subsection{环境准备}

创建一个项目并命名为\ascii{mars}，然后在项目的顶层目录初始化一个\ascii{git}库。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{初始化git库}}] 
$ git init 
 \end{c++}
\end{leftbar}  

\subsubsection{项目组织}

项目目录结构如下。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{项目组织}}]
mars
├── build
├── CMakeLists.txt
├── include
│   └── mars
├── src
│   ├── CMakeLists.txt
│   └── mars
└── test
    ├── CMakeLists.txt
    └── mars
 \end{c++}
\end{leftbar}

\subsubsection{CMakeList实现}

主控的\ascii{CMakeLists.txt}内容如下：

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{CMakeLists.txt}}]
project(mars)                                                                                  
cmake_minimum_required(VERSION 3.10)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++14")

include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include")

add_subdirectory(src)
add_subdirectory(test)
 \end{c++}
\end{leftbar}

\ascii{src/CMakeLists.txt}完成\ascii{mars}库的构建。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/CMakeLists.txt}}]
file(GLOB_RECURSE all_files *.cc)
add_library(mars STATIC ${all_files})
 \end{c++}
\end{leftbar}

\ascii{test/CMakeLists.txt}完成\ascii{mars-test}应用程序的构建，执行\ascii{mars}的测试用例。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/CMakeLists.txt}}]
file(GLOB_RECURSE all_files *.cc)
add_executable(mars-test ${all_files})
target_link_libraries(mars-test mars gtest gtest_main pthread)
 \end{c++}
\end{leftbar}

提交代码。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{提交代码}}] 
$ git add -A .
$ git commit -m"setup project"
 \end{c++}
\end{leftbar}  

\subsection{起航}

万事开头难，第一个用例跑起来并不容易。此处设计实现了一个最简单的测试用例，用于测试加法运算。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
#include <gtest/gtest.h>
#include "mars/core/TestCase.h"

namespace {
  struct SimpleTest : TestCase {
    bool wasRun = false;

  private:
    void run() override {
      wasRun = true;
    }
  };

  void run(TestCase& test) {
    test.run();
  }
}

TEST(SimpleTest, make_sure_test_case_can_run_normally) {
  SimpleTest test;
  run(test);

  ASSERT_TRUE(test.wasRun);
}
 \end{c++}
\end{leftbar}

\subsubsection{通过编译}

为了能够扩展用户的自定义行为，此处引入了多态技术，用户通过子类覆写\ascii{TestCase::run}成员函数。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestCase.h}}]
struct TestCase {
  virtual ~TestCase() {}
  virtual void run() = 0;
};
  \end{c++}
\end{leftbar}

\subsubsection{通过链接}

此处，创建一个空的\ascii{TestCase.cc}文件，仅仅为了\ascii{src/CMakeLists.txt}生成的\ascii{libmars.a}不为空，保证链接成功。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
 \end{c++}
\end{leftbar}

\subsubsection{通过测试}

接下来，在\ascii{build}的临时目录中，使用\ascii{cmake}构建工程。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{构建工程}}]
$ mkdir -p build && cd build
$ cmake ..
$ make
 \end{c++}
\end{leftbar}

运行测试。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{运行测试}}]
$ test/mars-test
Running main() from gtest_main.cc
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from SimpleTest
[ RUN      ] SimpleTest.make_sure_test_case_can_run_normally
[       OK ] SimpleTest.make_sure_test_case_can_run_normally (0 ms)
[----------] 1 test from SimpleTest (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (1 ms total)
[  PASSED  ] 1 test.
 \end{c++}
\end{leftbar}

\subsubsection{提交代码}

每当通过测试后，立即提交代码到\ascii{Git}库。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{提交代码}}]
$ git add -A .
$ git commit -m"pass first test case"
 \end{c++}
\end{leftbar}

\end{content}

\section{算法骨架}

\begin{content}

一般地，在执行测试前需要预置\ascii{setUp}实施环境的初始化工作。因此，对既有的用例实施重构。

\subsection{前置}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
#include <gtest/gtest.h>
#include "mars/core/TestCase.h"

namespace {
  struct SimpleTest : TestCase {
    bool wasSetUp = false;
    bool wasRun = false;

  private:
    void setUp() override {
      wasSetUp = true;
    }

    void runTest() override {
      wasRun = true;
    }
  };
}

TEST(SimpleTest, make_sure_test_case_can_run_normally) {
  SimpleTest test;
  test.run();

  ASSERT_TRUE(test.wasSetUp);
  ASSERT_TRUE(test.wasRun);
}
 \end{c++}
\end{leftbar}

\subsubsection{通过编译}

重构\ascii{TestCase}，仅公开\ascii{run}方法，并移除运行时多态的特性，它负责用例执行的运行时的算法骨架。搬迁运行时多态行为至私有的两个虚函数，用户可以根据自己的场景定制\ascii{setUp}与\ascii{runTest}，分别完成用例的初始化，及其测试执行。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestCase.h}}]
#ifndef AF6F59CF_EEF6_49C0_A674_EE599B415F7D
#define AF6F59CF_EEF6_49C0_A674_EE599B415F7D

struct TestCase {
  virtual ~TestCase() {}

  void run();

private:
  virtual void setUp() {}
  virtual void runTest() {}
};

#endif
  \end{c++}
\end{leftbar}

\subsubsection{通过测试}

实现\ascii{TestCase::run}的主体逻辑。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"

void TestCase::run() {
  setUp();
  runTest();
}

 \end{c++}
\end{leftbar}

测试通过，提交\ascii{Git}库。

\subsection{后置}

同理，测试执行后使用\ascii{tearDown}完成现场清理，用户通过定制私有的虚函数\ascii{tearDown}完成。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
#include <gtest/gtest.h>
#include "mars/core/TestCase.h"

namespace {
  struct SimpleTest : TestCase {
    bool wasSetUp = false;
    bool wasRun = false;
    bool wasTearDown = false;

  private:
    void setUp() override {
      wasSetUp = true;
    }

    void runTest() override {
      wasRun = true;
    }

    void tearDown() override {
      wasTearDown = true;
    }
  };
}

TEST(SimpleTest, make_sure_test_case_can_run_normally) {
  SimpleTest test;
  test.run();

  ASSERT_TRUE(test.wasSetUp);
  ASSERT_TRUE(test.wasRun);
  ASSERT_TRUE(test.wasTearDown);  
}
 \end{c++}
\end{leftbar}

\subsubsection{通过编译}

当用例执行完成后，\ascii{TestCase::tearDown}负责清理现场。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestCase.h}}]
#ifndef UUID_A5E84C94_CA28_4032_8014_2762BCE2D88F
#define UUID_A5E84C94_CA28_4032_8014_2762BCE2D88F

struct TestCase {
  virtual ~TestCase() {}

  void run();

private:
  virtual void setUp() {}
  virtual void runTest() {}
  virtual void tearDown() {}
};

#endif
  \end{c++}
\end{leftbar}

\subsubsection{通过测试}

测试通过，提交\ascii{Git}库。至此，完成了运行一个用例的主体逻辑，但缺乏异常处理机制，留待还需处理。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"

void TestCase::run() {
  setUp();
  runTest();
  tearDown();
}
 \end{c++}
\end{leftbar}



\end{content}

\section{隐式树}

\begin{content}

如果每个用例都需要手动\ascii{run}一次，显得太笨拙了。可以将测试用例打包，用一个简单的\ascii{for}循环依次执行每个用例。

\subsection{引入TestSuite}

为了确定每个\ascii{TestCase}都被执行，可以简单定制一个计数器\ascii{num}，用于断言已运行用例的数目。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestSuiteSpec.cc}}]
#include <gtest/gtest.h>
#include "mars/core/TestCase.h"
#include "mars/core/TestSuite.h"

namespace {
  int num = 0;

  struct FooTest : TestCase {
  private:
    void runTest() override {
      num++;
    }
  };
}

TEST(TestSuite, run_multi_test_cases_using_test_suite) {
  TestSuite suite;
  suite.add(new FooTest);
  suite.add(new FooTest);

  suite.run();

  ASSERT_EQ(2, num);
}
 \end{c++}
\end{leftbar}

\subsubsection{通过编译}

为了快速通过编译，创建\ascii{TestSuite}的头文件。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestSuite.h}}]
#include <vector>

struct TestCase;

struct TestSuite {
  void add(TestCase* test);
  void run();

private:
  std::vector<TestCase*> tests;
};
 \end{c++}
\end{leftbar}

\subsubsection{通过测试}

为了通过测试，可以快速实现\ascii{TestSuite::run}的逻辑。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestSuite.cc}}]
#include "mars/core/TestSuite.h"
#include "mars/core/TestCase.h"

void TestSuite::add(TestCase* test) {
  tests.push_back(test);
}

void TestSuite::run() {
  for (auto test : tests) {
    test->run();
  }
}
 \end{c++}
\end{leftbar}

\subsubsection{内存泄露}

\ascii{TestSuite}管理了若干\ascii{TestCase}的实例，引入析构函数释放动态创建并添加至\ascii{TestSuite}的所有\ascii{TestCase}实例。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestSuite.h}}]
#include <vector>

struct TestCase;

struct TestSuite {
  ~TestSuite();

  void add(TestCase* test);
  void run();

private:
  std::vector<TestCase*> tests;
};
 \end{c++}
\end{leftbar}

实现析构函数，释放动态内存。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestSuite.cc}}]
#include "mars/core/TestSuite.h"
#include "mars/core/TestCase.h"

void TestSuite::add(TestCase* test) {
  tests.push_back(test);
}

TestSuite::~TestSuite() {
  for (auto test : tests) {
    delete test;
  }
}

void TestSuite::run() {
  for (auto test : tests) {
    test->run();
  }
}
 \end{c++}
\end{leftbar}

\subsubsection{消除重复}

为了消除析构函数与\ascii{run}之间的重复代码，提取一个公共的\ascii{foreach}函数。注意，不要在头文件直接实现该模板函数。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestSuite.h}}]
#include <vector>

struct TestCase;

struct TestSuite {
  ~TestSuite();

  void add(TestCase* test);
  void run();

private:
  template <typename F>
  void foreach(F f) const;

private:
  std::vector<TestCase*> tests;
};
 \end{c++}
\end{leftbar}

因此，设计得到两个独立变化的方向。

\begin{enum}
  \eitem{\ascii{迭代算法：因存储结构变化而变化(目前实现为线性列表，不排除将来实现为map)；}}
  \eitem{\ascii{处理算子：存在删除，计数，运行等操作。}}
\end{enum}

可以使用\ascii{Lambda}表达式定制各种算子，实现差异化配置，实现对迭代算法的高度复用。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestSuite.cc}}]
#include "mars/core/TestSuite.h"
#include "mars/core/TestCase.h"

void TestSuite::add(TestCase* test) {
  tests.push_back(test);
}

template <typename F>
inline void TestSuite::foreach(F f) const {
  for (auto test : tests) {
    f(test);
  }
}

TestSuite::~TestSuite() {
  foreach([](auto test) {
    delete test;
  });
}

void TestSuite::run() {
  foreach([](auto test) {
    test->run();
  });
}
 \end{c++}
\end{leftbar}

\subsection{嵌套结构}

为了实现更好的可扩展性，\ascii{TestSuite}不仅能打包\ascii{TestCase}实例，也应该能够打包\ascii{TestSuite}实例，实现隐式的树结构。

为了能够添加更多的用例，需要对计数器\ascii{num}实施初始化。当执行用例时，确保\ascii{num}被初始化为\ascii{0}；否则测试用例之间存在数据脏写的错误依赖。另外，此处没有直接调用\ascii{TestSuite::run}，而是使用更为抽象的\ascii{Test::run}，测试装置将更加稳定。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestSuiteSpec.cc}}]
#include <gtest/gtest.h>
#include "mars/core/TestCase.h"
#include "mars/core/TestSuite.h"

namespace {
  int num = 0;

  struct FooTest : TestCase {
  private:
    void runTest() override {
      num++;
    }
  };

  struct TestSuiteSpec : testing::Test {
  private:
    void SetUp() override {
      num = 0;  // init!!!
    }

  protected:
    void run(::Test& test) {
      test.run();
    }
  };
}

TEST_F(TestSuiteSpec, run_multi_test_cases_using_test_suite) {
  TestSuite suite;
  suite.add(new FooTest);
  suite.add(new FooTest);

  run(suite);

  ASSERT_EQ(2, num);
}

TEST_F(TestSuiteSpec, package_test_suite_into_another_test_suite) {
  auto inner = new TestSuite;
  inner->add(new FooTest);

  TestSuite outter;
  outter.add(new FooTest);
  outter.add(inner);

  run(outter);

  ASSERT_EQ(2, result.runCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{提取抽象}

为了能够兼容\ascii{TestCase}与\ascii{TestSuite}，使得两者之间无差异化。因此，提取两者的共同抽象\ascii{Test}。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/Test.h}}]
struct Test {
  virtual ~Test() {}
  virtual void run() = 0;
};
 \end{c++}
\end{leftbar}

\subsubsection{重构TestCase}

\ascii{TestCase}除了默认的构造函数是\ascii{public}的，其它都是\ascii{private}的。尤其关注被覆写的\ascii{TestCase::run}，显式地声明为\ascii{private}，逼迫用户使用\ascii{Test::run}的抽象接口，而“面向接口编程”是一种良好的\ascii{OO}设计原则。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestCase.h}}]
#include "mars/core/Test.h"

struct TestCase : Test {
private:
  void run() override;

private:
  virtual void setUp() {}
  virtual void runTest() {}
  virtual void tearDown() {}
};
 \end{c++}
\end{leftbar}

\subsubsection{重构TestSuite}

同理，\ascii{TestSuite}也应该被重构使用\ascii{Test}的抽象类型，而非使用\ascii{TestCase}的具体类型。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestSuite.h}}]
#include <vector>
#include "mars/core/Test.h"

struct TestSuite : Test {
  ~TestSuite();
  void add(Test* test);

private:
  void run() override;

private:
  template <typename F>
  void foreach(F f) const;

private:
  std::vector<Test*> tests;
};
 \end{c++}
\end{leftbar}

同理，实现也应该使用\ascii{Test}的抽象类型。因为使用\ascii{auto}，实现文件只用修改\ascii{add}的签名即可。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestSuite.cc}}]
#include "mars/core/TestSuite.h"

void TestSuite::add(Test* test) {
  tests.push_back(test);
}

template <typename F>
inline void TestSuite::foreach(F f) const {
  for (auto test : tests) {
    f(test);
  }
}

TestSuite::~TestSuite() {
  foreach([](auto test) {
    delete test;
  });
}

void TestSuite::run() {
  foreach([](auto test) {
    test->run();
  });
}
 \end{c++}
\end{leftbar}

\end{content}

\section{聚集参数}

\begin{content}

在之前的测试用例里，在匿名命名空间内引入计数器\ascii{num}。当\ascii{TestCase}被执行时，其\ascii{num++}。

这是一种脆弱的设计，用户需要小心地维护计数器的初始化，也需要用户精细控制计数器累加的时机。一则容易引入不经意的错误，二则让计数器的操作散乱到各个覆写的\ascii{TestCase::runTest}子类之中。

\subsection{引入TestResult}

为了消除这个不稳定的设计，这里引入\ascii{TestResult}的抽象，将计数器维护的职责剥离出来。其中，\ascii{TestResult}扮演了聚集参数的角色。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestSuiteSpec.cc}}]
#include <gtest/gtest.h>
#include "mars/core/TestCase.h"
#include "mars/core/TestSuite.h"
#include "mars/core/TestResult.h"

namespace {
  struct TestSuiteSpec : testing::Test {
    void run(::Test& test) {
      test.run(result);
    }

  protected:
    TestResult result;
  };
}

TEST_F(TestSuiteSpec, run_multi_test_cases_using_test_suite) {
  TestSuite suite;
  suite.add(new TestCase);
  suite.add(new TestCase);

  run(suite);

  ASSERT_EQ(2, result.runCount());
}

TEST_F(TestSuiteSpec, package_test_suite_into_another_test_suite) {
  auto inner = new TestSuite;
  inner->add(new TestCase);

  TestSuite outter;
  outter.add(new TestCase);
  outter.add(inner);

  run(outter);

  ASSERT_EQ(2, result.runCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{通过编译}

\ascii{TestResult}维护了一个计数器，负责计数器初始化，累计操作数等职责。
g

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
struct TestResult {
  TestResult();
  int runCount() const;

private:
  int runTests;
};
 \end{c++}
\end{leftbar}

\subsubsection{通过链接}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"

TestResult::TestResult() : runTests(0) {
}

int TestResult::runCount() const {
  return runTests;
}
 \end{c++}
\end{leftbar}

\subsubsection{通过测试}

为了通过测试，当执行\ascii{TestCase::run}时，通知\ascii{TestResult}累加计数器。为了使得代码具有层次感，提取了\ascii{TestCase::runBare}的子函数，使得\ascii{TestCase::run}的主干更加清晰明了。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare() {
  setUp();
  runTest();
  tearDown();
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare();
}
 \end{c++}
\end{leftbar}

\ascii{TestResult::run}则实现简单的计数器累加操作。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
void TestResult::run() {
  runTests++;
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\end{content}

\section{异常处理}

\begin{content}

至此，框架不能处理任何异常逻辑。当用户调用\ascii{ASSERT\_EQ}失败时，抛出\ascii{AssertionError}异常，框架捕获该异常，标记该测试执行为\ascii{Failure}；如果抛出其他异常，则标记该测试执行为\ascii{Error}。区分这两种异常类型，使得用户可以审查自己的测试用例，并修复失败的用例。

\subsection{断言失败}

当用例的断言失败，打印诸如如下信息，提示用户修复失败的用例。

\begin{leftbar}
 \begin{python}[caption={测试失败}]
/home/horance/code/cpp/mars/test/mars/core/TestCaseSpec.cc:33
expected value == 2, but got 0
 \end{python}
\end{leftbar}

接下来，构建失败的用例，在\ascii{runTest}时抛出异常\ascii{AssertionError}，模拟断言失败的场景。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/TestCaseSpec.cc}}]
#include "mars/except/AssertionError.h"

namespace {
  struct AssertionFailedTest : TestCase {
    void runTest() override {
      throw AssertionError("test.cpp:57", "expected value == 2, but got 3");
    }
  };
}

TEST_F(TestCaseSpec, throw_assertion_error_on_run_test) {
  AssertionFailedTest test;
  run(test);

  ASSERT_EQ(1, result.failCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{异常类}

为了通过编译，引入\ascii{AssertionError}的异常类。它携带了断言失败处的文件名与行号，及其用例断言失败的具体原因。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/except/AssertionError.h}}]
struct AssertionError : std::exception {
  AssertionError(const std::string& src, const std::string& msg);
  ~AssertionError() noexcept = default;

  const char* what() const noexcept;

private:
  std::string msg;
};
 \end{c++}
\end{leftbar}

\ascii{AssertionError}实现如下。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/except/AssertionError.cc}}]
#include "mars/except/AssertionError.h"

AssertionError::AssertionError(const std::string& src,
  const std::string& msg) : msg(src + "\n" + msg) {
}

const char* AssertionError::what() const noexcept {
  return msg.c_str();
}
 \end{c++}
\end{leftbar}

\subsubsection{通过编译}

\ascii{TestResult}维护了一个计数器，负责计数器初始化，累计操作数等职责。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
struct TestResult {
  TestResult();

  void run();
  void fail();

  int runCount() const;
  int failCount() const;

private:
  int numOfRuns;
  int numOfFails;
};
 \end{c++}
\end{leftbar}

\subsubsection{通过链接}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"

TestResult::TestResult() : numOfRuns(0), numOfFails(0) {
}

int TestResult::runCount() const {
  return numOfRuns;
}

int TestResult::failCount() const {
  return numOfFails;
}

void TestResult::run() {
  numOfRuns++;
}

void TestResult::fail() {
  numOfFails++;
}
 \end{c++}
\end{leftbar}

\subsubsection{通过测试}

为了通过测试，当执行\ascii{TestCase::run}时，捕获异常并通知\ascii{TestResult}累加计数器。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare(TestResult& result) {
  setUp();

  try {
    runTest();
  } catch (const AssertionError&) {
    result.fail();
  }

  tearDown();
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare(result);
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{前置失败}

\ascii{TestCase}执行时，还未执行至\ascii{runTest}时，执行\ascii{setUp}就失败了。构建失败的用例，模拟前置失败的场景。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/TestCaseSpec.cc}}]
namespace {
  struct AssertionFailedOnSetUpTest : TestCase {
    bool wasRun = false;

    void setUp() override {
      throw AssertionError("test.cpp:57", "expected value == 2, but got 3");
    }

    void runTest() override {
      wasRun = true;
    }
  };
}

TEST_F(TestCaseSpec, throw_assertion_error_on_setup) {
  AssertionFailedOnSetUpTest test;
  run(test);

  ASSERT_FALSE(test.wasRun);
  ASSERT_EQ(1, result.failCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{通过测试}

为了通过测试，当执行\ascii{TestCase::setUp}时，捕获异常并通知\ascii{TestResult}累加计数器，并立即终止该用例的执行；毕竟环境没准备好，强制执行用例毫无意义。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare(TestResult& result) {
  try {
    setUp();
  } catch (const AssertionError&) {
    result.fail();
    return;
  }

  try {
    runTest();
  } catch (const AssertionError&) {
    result.fail();
  }

  tearDown();
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare(result);
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{后置失败}

\ascii{TestCase}执行时，执行完\ascii{runTest}时，接着执行\ascii{tearDown}时失败了。构建失败的用例，模拟后置失败的场景。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/TestCaseSpec.cc}}]
namespace {
  struct AssertionFailedOnTearDownTest : TestCase {
    void tearDown() override {
      throw AssertionError("test.cpp:57", "expected value == 2, but got 3");
    }
  };
}

TEST_F(TestCaseSpec, throw_assertion_error_on_tear_down) {
  AssertionFailedOnTearDownTest test;
  run(test);

  ASSERT_EQ(1, result.failCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{通过测试}

为了通过测试，当执行\ascii{TestCase::tearDown}时，捕获异常并通知\ascii{TestResult}累加计数器。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare(TestResult& result) {
  try {
    setUp();
  } catch (const AssertionError&) {
    result.fail();
    return;
  }

  try {
    runTest();
  } catch (const AssertionError&) {
    result.fail();
  }

  try {
    tearDown();
  } catch (const AssertionError&) {
    result.fail();
  }
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare(result);
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{异常与错误}

当抛出\ascii{AssertionError}，称之为\ascii{failure}；当抛出其他异常，诚挚为\ascii{Error}。构建失败的用例，模拟其他异常抛出的场景。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/TestCaseSpec.cc}}]
namespace {
  struct StdExceptionTest : TestCase {
    void runTest() override {
      throw std::exception();
    }
  };
}

TEST_F(TestCaseSpec, throw_std_exception_on_run_test) {
  StdExceptionTest test;
  run(test);

  ASSERT_EQ(0, result.failCount());
  ASSERT_EQ(1, result.errorCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{捕获异常}

当执行\ascii{TestCase::runTest}时，捕获\ascii{std::exception}异常，并通知\ascii{TestResult::error}累加计数器。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare(TestResult& result) {
  try {
    setUp();
  } catch (const AssertionError&) {
    result.fail();
    return;
  }

  try {
    runTest();
  } catch (const AssertionError&) {
    result.fail();
  } catch (const std::exception&) {
    result.error();
  }

  try {
    tearDown();
  } catch (const AssertionError&) {
    result.fail();
  }
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare(result);
}
 \end{c++}
\end{leftbar}

\subsubsection{错误计数器}

增加\ascii{TestResult::errorCount}的成员函数，及其相应的计数器。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
struct TestResult {
  TestResult();

  void run();
  void fail();

  int runCount() const;
  int failCount() const;
  int errorCount() const;

private:
  int numOfRuns;
  int numOfFails;
  int numOfErrors;
};
 \end{c++}
\end{leftbar}

\subsubsection{通过链接}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"

TestResult::TestResult()
  : numOfRuns(0), numOfFails(0)， numOfErrors(0) {
}

int TestResult::runCount() const {
  return numOfRuns;
}

int TestResult::failCount() const {
  return numOfFails;
}

int TestResult::failCount() const {
  return numOfErrors;
}

void TestResult::run() {
  numOfRuns++;
}

void TestResult::fail() {
  numOfFails++;
}

void TestResult::error() {
  numOfErrors++;
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{未知错误}

当抛出非\ascii{std::exception}，称之为未知的错误。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/TestCaseSpec.cc}}]
namespace {
  struct UnknownExceptionTest : TestCase {
    void runTest() override {
      throw std::out_of_range("overflow");
    }
  };
}

TEST_F(TestCaseSpec, throw_unknown_exception_on_run_test) {
  UnknownExceptionTest test;
  run(test);

  ASSERT_EQ(0, result.failCount());
  ASSERT_EQ(1, result.errorCount());
}
 \end{c++}
\end{leftbar}

\subsubsection{捕获异常}

当执行\ascii{TestCase::runTest}时，捕获未知的异常，并通知\ascii{TestResult::error}累加计数器。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare(TestResult& result) {
  try {
    setUp();
  } catch (const AssertionError&) {
    result.fail();
    return;
  }

  try {
    runTest();
  } catch (const AssertionError&) {
    result.fail();
  } catch (const std::exception&) {
    result.error();
  } catch (...) {
    result.error();
  }

  try {
    tearDown();
  } catch (const AssertionError&) {
    result.fail();
  }
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare(result);
}
 \end{c++}
\end{leftbar}

测试通过。

\subsection{完备的异常处理}

依次构建测试用例，小步快走，驱动出完备的异常处理逻辑。但是，异常臃肿，异常难堪；在开启重构之前，还需要得到更多关于异常的信息，并通知给\ascii{TestResult}。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestCase.cc}}]
#include "mars/core/TestCase.h"
#include "mars/core/TestResult.h"

void TestCase::runBare(TestResult& result) {
  try {
    setUp();
  } catch (const AssertionError&) {
    result.fail();
    return;
  } catch (const std::exception&) {
    result.error();
    return;
  } catch (...) {
    result.error();
    return;
  }

  try {
    runTest();
  } catch (const AssertionError&) {
    result.fail();
  } catch (const std::exception&) {
    result.error();
  } catch (...) {
    result.error();
  }

  try {
    tearDown();
  } catch (const AssertionError&) {
    result.fail();
  } catch (const std::exception&) {
    result.error();
  } catch (...) {
    result.error();
  }
}

void TestCase::run(TestResult& result) {
  result.run();
  runBare(result);
}
 \end{c++}
\end{leftbar}

\subsection{传递异常}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/TestCaseSpec.cc}}]
namespace {
  struct AssertionFailedTest : TestCase {
    void runTest() override {
      throw AssertionError("test.cpp:57", "expected value == 2, but got 3");
    }
  };
}

TEST_F(TestCaseSpec, throw_assertion_error_on_run_test) {
  AssertionFailedTest test;
  run(test);

  ASSERT_EQ(1, result.);
  ASSERT_EQ(0, result.errorCount());
}
 \end{c++}
\end{leftbar}

\end{content}