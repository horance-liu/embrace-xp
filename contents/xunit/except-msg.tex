\begin{savequote}[45mm]
\ascii{Any fool can write code that a computer can understand. Good programmers write code that humans can understand.}
\qauthor{\ascii{- Martin Flower}}
\end{savequote}

\chapter{异常信息} 
\label{ch:except-msg}

\begin{content}

\end{content}

\section{异常信息}

\begin{content}

当用例失败后，用户期望终端打印如下信息，方便用户快速修复失败的用例。

\begin{leftbar}
 \begin{c++}
assertion fail in the runTest
/home/horance/code/cpp/cut/test/hamcrest/core/ComparatorTest.cpp:12
Expected: a value eq <254: int>
     but: <255: int> eq <254: int> got false
 \end{c++}
\end{leftbar}

异常信息包括如下几个重要逻辑信息：

\begin{enum}
  \eitem{\ascii{Why}: 指明用例失败的原因}
    \begin{enum}
      \eitem{\ascii{assertion fail}: 断言失败}
      \eitem{\ascii{uncaught std::exception}: 被测系统抛出\ascii{std::exception}或子异常}
      \eitem{\ascii{uncaught unknown exception}: 被测系统抛出其他未知异常}
    \end{enum}
  \eitem{\ascii{Where}: 异常抛出的地点}
    \begin{enum}
      \eitem{\ascii{in the setUp}}
      \eitem{\ascii{in the runTest}}
      \eitem{\ascii{in the tearDown}}
    \end{enum}
  \eitem{\ascii{What}: 异常携带的详细信息}
    \begin{enum}
      \eitem{\ascii{源文件}}
      \eitem{\ascii{行号}}
      \eitem{\ascii{异常详细信息}: \ascii{what}成员函数返回值}
    \end{enum}
\end{enum}

\end{content}

\section{断言失败}

\begin{content}

\subsection{测试用例}

重构既有的测试用例，当\ascii{runTest}因断言失败而抛出\ascii{AssertionError}异常时，在\ascii{TestResult}收集异常信息。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
namespace {
  struct AssertionFailedTest : TestCase {
    const char* expectMsg() const {
      return "assertion fail in the runTest\n"
             "TestCaseSpec.cpp:57\n"
             "expected value == 2, but got 3";
    }

  private:
    void runTest() override {
      throw AssertionError("TestCaseSpec.cpp:57", "expected value == 2, but got 3");
    }
  };
}

TEST_F(TestCaseSpec, throw_assertion_error_on_run_test) {
  AssertionFailedTest test;
  run(test);

  auto& fails = result.getFailures(); 
  ASSERT_EQ(1, fails.size());
  ASSERT_EQ(test.expectMsg(), fails[0]);
}
 \end{c++}
\end{leftbar}

\subsection{缓存异常}

为了快速通过测试，对外提供\ascii{getFailures}查询接口，供外部用户获取异常信息。实现较为简单，在\ascii{TestResult}建立相应的数据结构，完成异常信息的收集。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
#include <vector>
#include <string>

struct TestCaseFunctor;

struct TestResult {
  TestResult();

  int failCount() const;
  int errorCount() const;

  const std::vector<std::string>& getFailures() const;

  bool protect(const TestCaseFunctor&);

private:
  void onFail(std::string&& msg);
  void onError();

private:
  int numOfFails;
  int numOfErrors;

  std::vector<std::string> failures;
};
 \end{c++}
\end{leftbar}

当异常被捕获后，通过断言失败的监听接口\ascii{onFail}添加至缓存。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/except/AssertionError.h"

// ...

const std::vector<std::string>& TestResult::getFailures() const {
  return failures;
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(std::string("assertion fail") + ' ' + f.where() + '\n' + e.what());
  } catch (const std::exception&) {
    onError();
  } catch (...) {
    onError();
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg));
  numOfFails++;
}

void TestResult::onError() {
  numOfError++;
}
 \end{c++}
\end{leftbar}

\subsection{获取异常位置}

得益于\ascii{TestCaseFunctor}的可扩展性，可以方便携带额外的元数据，包括增加异常位置的查询接口，。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
struct TestCaseFunctor {
  virtual bool operator()() const = 0;
  virtual const char* where() const = 0;

  virtual ~TestCaseFunctor() {}
};
 \end{c++}
\end{leftbar}

在\ascii{TestCase::run}实现中，通过修改\ascii{PROTECT}宏定义，并覆写\ascii{Functor::where}成员函数，报告异常发生的位置信息。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
namespace {
  struct Functor : TestCaseFunctor {
    using Method = void(TestCase::*)();

    Functor(TestCase* self, Method method, const char* place)
      : self(self), method(method), place(place) {
    }

  private:
    bool operator()() const override {
      (self->*method)();
      return true;
    }

    const char* where() const override {
      return place;
    }

  private:
    TestCase* self;
    Method method;
    const char* place;
  };
}

#define PROTECT(method) \
    result.protect(Functor(this, &TestCase::method, "in the "#method))

void TestCase::run(TestResult& result) {
  if (PROTECT(setUp)) {
    PROTECT(runTest);
  }
  PROTECT(tearDown);
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\end{content}

\section{错误}

\begin{content}

\subsection{测试用例}

模拟在\ascii{runTest}抛出错误，并\ascii{std::exception}异常，模拟被测系统失败。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
namespace {
  struct StdExceptionTest : TestCase {
    const char* expectMsg() const {
      return "uncaught std::exception in the runTest\n"
             "std::exception";
    }

  private:
    void runTest() override {
      throw std::exception();
    }
  };
}

TEST_F(TestCaseSpec, throw_std_exception_on_run_test) {
  StdExceptionTest test;
  run(test);

  auto& errors = result.getErrors();
  ASSERT_EQ(1, errors.size());
  ASSERT_EQ(test.expectMsg(), errors.front());
}
 \end{c++}
\end{leftbar}

\subsection{缓存错误}

依葫芦画瓢，\ascii{TestResult}增加查询接口\ascii{getErrors}，重构错误的监听接口\ascii{onError}，将异常信息添加至缓存\ascii{errors}中。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
#include <vector>
#include <string>

struct TestCaseFunctor;

struct TestResult {
  TestResult();

  int failCount() const;
  int errorCount() const;

  const std::vector<std::string>& getFailures() const;
  const std::vector<std::string>& getErrors() const;

  bool protect(const TestCaseFunctor&);

private:
  void onFail(std::string&& msg);
  void onError(std::string&& msg);

private:
  int numOfFails;
  int numOfErrors;

  std::vector<std::string> failures;
  std::vector<std::string> errors;
};
 \end{c++}
\end{leftbar}

实现也较为简单。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/core/internal/TestCaseFunctor.h"
#include "mars/except/AssertionError.h"

// ...

const std::vector<std::string>& TestResult::getFailures() const {
  return failures;
}

const std::vector<std::string>& TestResult::getErrors() const {
  return errors;
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(std::string("assertion fail") + ' ' + f.where() + '\n' + e.what());
  } catch (const std::exception& e) {
    onError(std::string("uncaught std::exception") + ' ' + f.where() + '\n' + e.what());
  } catch (...) {
    onError("");
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg));
  numOfFails++;
}

void TestResult::onError(std::string&& msg) {
  errors.emplace_back(std::move(msg));
  numOfErrors++;
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\end{content}

\section{未知错误}

\begin{content}

\subsection{测试用例}

模拟在\ascii{runTest}抛出错误，并\ascii{std::exception}异常，模拟被测系统失败。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
namespace {
  struct UnknownException {};

  struct UnknownExceptionTest : TestCase {
    const char* expectMsg() const {
      return "uncaught unknown exception in the runTest\n";
    }

  private:
    void runTest() override {
      throw UnknownException();
    }
  };
}

TEST_F(TestCaseSpec, cache_error_if_throw_unknown_exception_on_run_test) {
  UnknownExceptionTest test;
  run(test);

  auto& errors = result.getFailures();
  ASSERT_FALSE(errors.empty());

  auto& error = errors.front();
  ASSERT_TRUE(error.isError());
  ASSERT_EQ(test.expectMsg(), error.getExceptionMsg());
}
 \end{c++}
\end{leftbar}

\subsection{缓存错误}

捕获未知错误，并添加至缓存。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/core/internal/TestCaseFunctor.h"
#include "mars/except/AssertionError.h"

// ...

const std::vector<std::string>& TestResult::getFailures() const {
  return failures;
}

const std::vector<std::string>& TestResult::getErrors() const {
  return errors;
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(std::string("assertion fail") + ' ' + f.where() + '\n' + e.what());
  } catch (const std::exception& e) {
    onError(std::string("uncaught std::exception") + ' ' + f.where() + '\n' + e.what());
  } catch (...) {
    onError(std::string("uncaught unknown exception") + ' ' + f.where() + '\n' + "");
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg));
  numOfFails++;
}

void TestResult::onError(std::string&& msg) {
  errors.emplace_back(std::move(msg));
  numOfErrors++;
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{计数器实现}

此时，可以删除\ascii{numOfErrors, numOfFailure}的计数器，通过查询集合的\ascii{size}直接返回。当然，\ascii{TestResult}的默认构造函数也无用了，也一并删除之。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"

// ...

int TestResult::failCount() const {
  return failures.size();
}

int TestResult::::errorCount() const {
  return errors.size();
}

const std::vector<std::string>& TestResult::getFailures() const {
  return failures;
}

const std::vector<std::string>& TestResult::getErrors() const {
  return errors;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg));
}

void TestResult::onError(std::string&& msg) {
  errors.emplace_back(std::move(msg));
}
 \end{c++}
\end{leftbar}

\end{content}

\section{值对象}

\begin{content}

\subsection{测试用例}

使用字符串表示异常信息是一种脆弱的设计，可以将其重构为值对象，从而得到更稳定的设计。首先，重构既有的测试用例，使其失败。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{test/mars/core/TestCaseSpec.cc}}]
namespace {
  struct AssertionFailedTest : TestCase {
    const char* expectMsg() const {
      return "assertion fail in the runTest\n"
             "test.cpp:57\n"
             "expected value == 2, but got 3";
    }

  private:
    void runTest() override {
      throw AssertionError("test.cpp:57", "expected value == 2, but got 3");
    }
  };
}

TEST_F(TestCaseSpec, cache_failure_if_throw_assertion_error_on_run_test) {
  AssertionFailedTest test;
  run(test);

  auto& failures = result.getFailures();
  ASSERT_EQ(1, failures.size());

  auto& failure = failures[0];
  ASSERT_TRUE(failure.isFailure());
  ASSERT_EQ(test.expectMsg(), failure.getExceptionMsg());
}
 \end{c++}
\end{leftbar}

测试用例使用\ascii{auto}自动类型推演，没有显式给出具体的类型。但是，该值对象约定具有\ascii{isFailure， getExceptionMsg}的接口定义。

\subsection{定义值对象}

为了快速通过测试，定义值对象\ascii{TestFailure}，相对原生的\ascii{std::string}，它相对更加稳定和抽象，并更具有表达力。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/except/TestFailure.h}}]
#include <string>

struct TestFailure {
  TestFailure(std::string&& msg, bool failure);

  bool isFailure() const;
  bool isError() const;
  const std::string& getExceptionMsg() const;

private:
  std::string msg;
  bool failure;
};
 \end{c++}
\end{leftbar}

其实现非常简单。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/except/TestFailure.cc}}]
#include "mars/except/TestFailure.h"

TestFailure::TestFailure(std::string&& msg, bool failure)
  : msg(std::move(msg)), failure(failure) {
}

bool TestFailure::isError() const {
  return !failure;
}

bool TestFailure::isFailure() const {
  return failure;
}

const std::string& TestFailure::getExceptionMsg() const {
  return msg;
}
 \end{c++}
\end{leftbar}

\subsection{重构：断言失败}

将\code{failures}的元素类型\code{std::string}重构为\code{TestFailure}。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
#include <vector>
#include <string>
#include "mars/except/TestFailure.h"

struct TestCaseFunctor;

struct TestResult {
  int failCount() const;
  int errorCount() const;

  const std::vector<TestFailure>& getFailures() const;
  const std::vector<std::string>& getErrors() const;

  bool protect(const TestCaseFunctor&);

private:
  void onFail(std::string&& msg);
  void onError(std::string&& msg);

private:
  std::vector<TestFailure> failures;
  std::vector<std::string> errors;
};
 \end{c++}
\end{leftbar}

在实现文件中，重构完成\ascii{TestFailure}的缓存。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/core/internal/TestCaseFunctor.h"
#include "mars/except/AssertionError.h"

// ...

const std::vector<TestFailure>& TestResult::getFailures() const {
  return failures;
}

const std::vector<std::string>& TestResult::getErrors() const {
  return errors;
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(std::string("assertion fail") + " " + f.where() + "\n" + e.what());
  } catch (const std::exception& e) {
    onError(std::string("uncaught std::exception") + " " + f.where() + "\n" + e.what());
  } catch (...) {
    onError(std::string("uncaught unknown exception") + " " + f.where() + "\n" + "");
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg), true);
}

void TestResult::onError(std::string&& msg) {
  errors.emplace_back(std::move(msg));
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{重构：错误}

依葫芦画瓢，添加测试用例，

将\code{errors}的元素类型\code{std::string}重构为\code{TestFailure}。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
#include <vector>
#include <string>
#include "mars/except/TestFailure.h"

struct TestCaseFunctor;

struct TestResult {
  int failCount() const;
  int errorCount() const;

  const std::vector<TestFailure>& getFailures() const;
  const std::vector<TestFailure>& getErrors() const;

  bool protect(const TestCaseFunctor&);

private:
  void onFail(std::string&& msg);
  void onError(std::string&& msg);

private:
  std::vector<TestFailure> failures;
  std::vector<TestFailure> errors;
};
 \end{c++}
\end{leftbar}

在实现文件中，重构完成\ascii{TestFailure}的构造与缓存。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/core/internal/TestCaseFunctor.h"
#include "mars/except/AssertionError.h"

// ...

const std::vector<TestFailure>& TestResult::getFailures() const {
  return failures;
}

const std::vector<TestFailure>& TestResult::getErrors() const {
  return errors;
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(std::string("assertion fail") + " " + f.where() + "\n" + e.what());
  } catch (const std::exception& e) {
    onError(std::string("uncaught std::exception") + " " + f.where() + "\n" + e.what());
  } catch (...) {
    onError(std::string("uncaught unknown exception") + " " + f.where() + "\n" + "");
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg), true);
}

void TestResult::onError(std::string&& msg) {
  errors.emplace_back(std::move(msg), false);
}
 \end{c++}
\end{leftbar}

至此，测试通过。

\subsection{实现统一}

在\ascii{TestResult}中便可以删除既有的\ascii{errors}列表，及其相关的查询接口\ascii{getErrors}；统一使用\ascii{failures}一个缓存列表，及其\ascii{getFailures}一个查询接口。至此，消除了失败与错误两种重复表示，统一了接口的使用方式。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{include/mars/core/TestResult.h}}]
#include <string>
#include <vector>
#include <mars/except/TestFailure.h>

struct TestCaseFunctor;

struct TestResult {
  int failCount() const;
  int errorCount() const;

  const std::vector<TestFailure>& getFailures() const;

  bool protect(const TestCaseFunctor&);

private:
  void onFail(std::string&& msg);
  void onError(std::string&& msg);

private:
  std::vector<TestFailure> failures;
};
 \end{c++}
\end{leftbar}

在实现文件中，替换所有\ascii{errors}为\ascii{failures}。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/core/internal/TestCaseFunctor.h"
#include "mars/except/AssertionError.h"
#include "mars/except/TestFailure.h"

// ...

const std::vector<TestFailure>& TestResult::getFailures() const {
  return failures;
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(std::string("assertion fail") + ' ' + f.where() + '\n' + e.what());
  } catch (const std::exception& e) {
    onError(std::string("uncaught std::exception") + ' ' + f.where() + '\n' + e.what());
  } catch (...) {
    onError(std::string("uncaught unknown exception") + ' ' + f.where() + '\n' + "");
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg), true);
}

void TestResult::onError(std::string&& msg) {
  failures.emplace_back(std::move(msg), false);
}
 \end{c++}
\end{leftbar}

\subsubsection{计数器实现}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
#include "mars/core/TestResult.h"
#include "mars/except/TestFailure.h"

// ...

template <typename Pred>
inline int TestResult::count(Pred pred) const {
  return std::count_if(failures.begin(), failures.end(), pred);
}

int TestResult::failCount() const {
  return count([](auto& e) {
    return e.isFailure();
  });
}

int TestResult::errorCount() const {
  return count([](auto& e) {
    return e.isError();
  });
}
 \end{c++}
\end{leftbar}

\subsection{工厂方法}

创建异常信息的工厂方法\ascii{msg}，得到可复用的代码实现。

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
namespace {
  std::string msg(const char* why, const char* where, const char* what) {
    return std::string(why) + ' ' + where + '\n' + what;
  }
}

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    onFail(msg("assertion fail", f.where(), e.what()));
  } catch (const std::exception& e) {
    onError(msg("assertion fail", f.where(), e.what()));
  } catch (...) {
    onError(msg("assertion fail", f.where(), ""));
  }
  return false;
}

void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg), true);
}

void TestResult::onError(std::string&& msg) {
  failures.emplace_back(std::move(msg), false);
}
 \end{c++}
\end{leftbar}

\subsection{实用宏}

\begin{leftbar}
 \begin{c++}[caption={\ttfamily{src/mars/core/TestResult.cc}}]
inline void TestResult::onFail(std::string&& msg) {
  failures.emplace_back(std::move(msg), true);
}

inline void TestResult::onError(std::string&& msg) {
  failures.emplace_back(std::move(msg), false);
}

namespace {
  struct NilException {
    const char* what() const {
      return "";
    }
  };

  inline std::string msg(const char* why, const char* where, const char* what) {
    return std::string(why) + ' ' + where + '\n' + what;
  }
}

#define ON_FAIL(except)  onFail(msg(except, f.where(), e.what()))
#define ON_ERROR(except) onError(msg(except, f.where(), e.what()))

bool TestResult::protect(const TestCaseFunctor& f) {
  try {
    return f();
  } catch (const AssertionError& e) {
    ON_FAIL("assertion fail");
  } catch (const std::exception& e) {
    ON_ERROR("uncaught std::exception");
  } catch (...) {
    NilException e;
    ON_ERROR("uncaught unknown exception");
  }
  return false;
}
 \end{c++}
\end{leftbar}

\end{content}